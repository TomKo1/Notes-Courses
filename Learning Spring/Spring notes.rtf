{\rtf1\ansi\ansicpg1250\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red153\green168\blue186;\red32\green32\blue32;\red173\green169\blue32;
\red109\green109\blue109;\red191\green100\blue38;\red254\green187\blue91;\red133\green96\blue154;\red88\green118\blue71;
\red107\green0\blue1;\red246\green246\blue246;\red38\green38\blue38;\red50\green109\blue108;\red106\green0\blue108;
\red29\green0\blue255;\red173\green169\blue32;\red32\green32\blue32;\red153\green168\blue186;\red197\green195\blue255;
\red88\green118\blue71;\red191\green100\blue38;\red254\green187\blue91;\red225\green179\blue88;\red133\green96\blue154;
\red172\green172\blue172;\red149\green184\blue79;}
{\*\expandedcolortbl;;\csgenericrgb\c60000\c65882\c72941;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c67843\c66275\c12549;
\csgenericrgb\c42745\c42745\c42745;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c99608\c73333\c35686;\csgenericrgb\c52157\c37647\c60392;\csgenericrgb\c34510\c46275\c27843;
\cssrgb\c50196\c0\c0;\cssrgb\c97255\c97255\c97255;\cssrgb\c20000\c20000\c20000;\cssrgb\c24706\c49804\c49804;\cssrgb\c49804\c0\c49804;
\cssrgb\c16471\c0\c100000;\csgenericrgb\c67843\c66275\c12549;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c60000\c65882\c72941;\csgenericrgb\c77255\c76471\c100000;
\csgenericrgb\c34510\c46275\c27843;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c99608\c73333\c35686;\csgenericrgb\c88235\c70196\c34510;\csgenericrgb\c52157\c37647\c60392;
\csgenericrgb\c67451\c67451\c67451;\csgenericrgb\c58431\c72157\c30980;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11880\viewh10620\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
Notes took by me during doing course:\
		
\b\fs28 https://strefakursow.pl/kursy/programowanie/kurs_spring_framework_od_podstaw.html\
\

\b0 JPA -> zapisywanie i odczyt danych z bazy danych\
\
			SPRING BOOT\
Spring -> framework do tworzenia stron internetowych -> Dost\uc0\u281 pny r\'f3wnie\u380 \
Dla j\uc0\u281 zyk\'f3w pokrewnych -> Groovy, Kotlin (<3)\
\
- powsta\uc0\u322  jako alternatywna EJB (Enterprise Java Bean)\
\
- Spring Boot ->podzia\uc0\u322  modu\u322 \'f3w an paczki - \'82startery\'92 np. \'82spring-web-starter\'92 i \
Zarz\uc0\u261 dzanie wersjami ka\u380 dego z nich tak by nie dochodzi\u322 o do konfilkt\'f3w + autokonfiguracja + wbudowany serwer webowy (domy\u347 lnie Tomcat)\
\
\
Niezbedne narzedzia: \
	-> JDK jak zawsze\
	-> Maven \
\
// 			wygenerowanie projektu Spring Boot\
\
\
start.spring.io -> aplikacja webowa s\uc0\u322 u\u380 \u261 ca do wygenerowania aplikacji spring bootowych\
\
Group -> np. Firma\
Artefact -> nazwa projektu \
Dependencies -> zaleznosci np. Web (troche jak w Android Studio ? )\
\
//			przeglad plikow projektu\
\
.idea -> pliki polaczone z projektem w IDE InteliJ \
.mvn -> katalog gdzie .jar mavena i properties -> po to by w polaczeniu z mvnw mvnm.cmd kazy kto nie ma mavena mogl ten projekt odpalic\
\
src -> pliki zrodlowe jak i testowe\
\
.gitgnore -> git \
\
PrzykladowyProjekt.iml -> sklada caly projekt w calosc\
\
mvnm.cmd  i mvnw -> pliki skryptowe \
\
\
pom.xml -> plik zawierajacy konfiguracje Mavena -> WAZNE !!!\
\
		<groupId>\
		<version>\
		<packaging>\
		<name> -> nazwa projektu (generalnie dla ludzi)\
<properties> -> ustawienia projektu \
\
<dependencies> -> zaleznosci \
\
W src: 	\
		main -> logika\
			java -> pliki zrodlowe\
			resources -> application.properties -> propertiesy np. Adres bazy danych zwiazane z wewnetrznym dzialaniem (pom.xml jest og\'f3lnie dla Mavena)\
		test -> testy\
\
//				HELLO WORLD\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 CommandLineRunner\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 - interfejs CommandLineRunner (z metoda public void run(String\'85 args) throws Exception -> metoda ktora zostanie wywolana jak tylko Spring zakonczy swoja konfiguracje\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs24 \cf2 \cb3 \

\f1 \cf4 @Component \cf5 // klasa jest SpringBeanem\
\cf6 public class \cf2 Hi \cf6 implements \cf2 CommandLineRunner \{\
\
    \cf4 @Override\
    \cf6 public void \cf7 run\cf2 (String ... args) \cf6 throws \cf2 Exception\{\
\
        System.
\f2\i \cf8 out
\f1\i0 \cf2 .println(\cf9 "Hello world!!!"\cf2 )\cf6 ;\
        \
    \cf2 \}\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
/// 			fundamenty Spring Framework:\
\
	- Wstrzykiwanie zale\uc0\u380 no\u347 ci (Dependency Injection)\
	- Spring beans\
	- DI + Beans \
	- testowanie komponent\'f3w\
\
//		Wstrzykiwanie zale\uc0\u380 no\u347 ci (Dependency Injection) -> prostsze niz myslalem XD ;) \
\
Wstrzykiwanie to gdy w jakiejs klasie mamy pole reprezentujace jakis obiekt \
i do konstruktora takiej klasy przekazujemy obiekt odpowiedniego typu np. \
Quest quest = Quest(\'84Zabij smoka\'94) ; \
\
Knight knight1 = new Knight(\'84Tomek\'94, \'8420\'94, quest); // tutaj nastepuje wstrzykiwanie\
\
\
// sa w rodzaje wstrzykiwania: \
	-> przez konstruktor\
	-> przez metode ( najczesciej settera np. setQuest(Quest quest) -> moze byc problem z nullem \
\
Quest quest = Quest(\'84Zabij smoka\'94) ; \
\
Knight knight1 = new Knight(\'84Tomek\'94, \'8420\'94);\
knight1.setQuest(quest);\
\
\
//			Spring Beans, Kontekst, Kontener\
\
Spring Bean -> zwykle klasy Javy oznaczone odpowiedzni\uc0\u261  adnotacj\u261  (@Component) lub skonfigurowanie odpowiednio w XML \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf4 \cb3 @Component\
\cf6 public class \cf2 Castle \{\
\
    \cf6 private \cf2 String \cf8 name \cf2 = \cf9 "East Watch"\cf6 ;\
\
    public \cf7 Castle\cf2 ()\{\
\
    \}\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 // gdy spring bedzie startowal to doda taka klase do kontenera\
Kontener -> mapa klucz -> klasa  a wartosc -> instancja tej klasy\
Przy starcie jest tworzona nowa instancja klasy Castle (Beansa) i dodawana \
Do kontekstu -> jest w\'f3wczas gotowa do u\uc0\u380 ycia \
Czyli pod nazw\uc0\u261  \'84castle\'94 mamy instancje klasy Castle\
-> gdy aplikacja ko\uc0\u324 czy dzia\u322 anie aplikacja daje informacje kontenerowi zeby zniszczyl \
Beany i dopiero wtedy aplikacja konczy dzialanie \
\
-> kontener i \'84kilka uzytecznych funkcjonalnosci\'94 przechowywanych jest w Kontekscie -	> jest on przeszukiwany przez Springa pod kontem Beans\'f3w (@Component)\
\
-> metoda run ze Startera po zaladowaniu Beans\'f3w uzyskuje dost\uc0\u281 p do wszystkich klas implementuj\u261 cych interfejs CommandLineRunner i uruchamia ich metod\u281  run \
(String \'85 strings)\
\
//			cykla \uc0\u380 ycia Sptring Beans\
\
Mo\uc0\u380 emy zareagowa\u263  programistycznie na \'84utworzenie\'94 i \'84zniszczenie\'94 Beana \
\
- uzywamy do tego odpowiednich adnotacji: \
	\
	@PostConstruct\
	public void build()\{\
		System.out.println(\'84Wlasnie stworozono obiekt!\'94);\
	\}\
\
	@PreDestroy\
	public void tearDown()\{\
		System.out.println(\'84Wlasnie zniszcono obiekt!\'94);\
	\}\
\
//			wstrzykiwanie zale\uc0\u380 no\u347 ci + Spring Beans\
\
Z kontekstu springowego mozemy pobierac beany: \
\
\
Metoda run() \
\
Zwraca ConfihurableApplicationContext -> Mona go przypisac do referencji a nastepnie, wywolujac metode\
refCtx.getBean(\'84odpowiedniaNazwaBeana\'94); mozna uzyskac odpowiedniego Beana\
\
	
\f1\fs24 \cf6 \cb3 package \cf2 com.example.tomek.PrzykladowyProjekt\cf6 ;\
\
import \cf2 com.example.tomek.PrzykladowyProjekt.domain.Castle\cf6 ;\
import \cf2 org.springframework.boot.SpringApplication\cf6 ;\
import \cf2 org.springframework.boot.autoconfigure.\cf4 SpringBootApplication\cf6 ;\
import \cf2 org.springframework.context.ConfigurableApplicationContext\cf6 ;\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf4 @SpringBootApplication \cf5 // oznacza ze jest to glowna klasa startowa dla naszej\
// aplikacji\
\cf6 public class \cf2 PrzykladowyProjektApplication \{\
\
	\cf6 public static void \cf7 main\cf2 (String[] args) \{\
\
\
		ConfigurableApplicationContext ctx=SpringApplication.
\f2\i run
\f1\i0 (PrzykladowyProjektApplication.\cf6 class, \cf2 args)\cf6 ;\
\
		\cf2 Castle castle=(Castle)ctx.getBean(\cf9 "castle"\cf2 )\cf6 ;\
\
        \cf2 System.
\f2\i \cf8 out
\f1\i0 \cf2 .println(castle)\cf6 ;\
\
	\cf2 \}\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
// ALE MAMY LEPSZE METODY:\
\
	ale mozna zrobic:\
	1. Zmienna referencyjna odpowiedniego typu (np. Castle) w danej klasie\
	we wnetrzu ktorej znajduje sie metododa run z ktorej chcielibysmy uzyskac dostep 	do odpowiedniego beana nalezy oznaczyc jak nizej:\
	\
	@Autowired // tylko dla klas oznaczonych adnotacja @Component -> Beansow !!! -> bo musi byc przeciez w Kontenerze !!! -> jak 2 benay tej samej klasy ale pod inna nazwa to tez blad !!!\
	Castle castle; // dzieki temu gdy spring buduje ta klase to odszuka nam castle i wstrzyknie -> mozemy go uzyc \
\
//				Wstrzykiwanie typ\'f3w prymitywnych\
\
Do wstrzykiwania typ\'f3w prymitywnych s\uc0\u322 u\u380 y adnotacja \
@Value(\'84jakasWartoscOdpowiedniegoTypu\'94)\
\
@Value(\'84Lancelot\'94)\
private String name;\
\
@Value(\'8429\'94) // mimo ze wpisujemy Stringa to pod spodem jest parsowanie do int\
private int age;\
\
 Ale takie wstrzykiwanie to rzadko\uc0\u347 \u263 \
private String name = \'84Lancelot\'94;\
\
private int age = 27;\
\
cz\uc0\u281 stszym zastosowaniem adnotacji @Value jest wstrzykiwanie zawarto\u347 ci, kt\'f3r\u261  podali\u347 my w application.properties\
\
application.properties -> przechowuje propertiesy aplikacji \
\
np. Mozemy stworzyc \
my.castle.name=East Watch\
\
// . . .. teraz w klasie np.  Castle \
@Value(\'84$(my.castle.name))\
private String name; // tutaj wstrzykujemy properties\'92a\
// podawanie wartosci domyslnej ( gdyby nie.bylo danego propertiesa): \
@Value(\'84$(my.castle.name:East Watch)\'94)\
private String name;\
\
jezeli chcemy stworzyc wlasny plik propertiesow (oczywiscie w katalogu resources) to \
Musimy dodac odpowiedni\uc0\u261  adnotacje @PropertySource(\'84classpath:NazwaPlikuZProperties\'94)\
\
//			Rodzaje wstrzykiwania zale\uc0\u380 no\u347 ci w Spring Framework\
\
@Authowired -> 3 typ wstrzykiwania przez reflection API \
\
Mozna np. Wstrzykiwac rowniez do metody: \
@Autowired 	// tutaj wstrzykujemy rycerza\
public Castle(Knight knight)\{ // konstruktor\
	this.knight = knight; 	// knight to pole odpowiedniego typu\
\}\
\
\
- zeby wstrzykiwac do metody wystarczy tez dopisac adnotacje @Autowired\
public void setQuest(Quest quest)\{ // quest jest wstrzykiwany  -> setQuest to metoda wstrzykujaca\
	this.quest = quest; // quest to odpowiednie pole klasy\
\}\
\
//			testowanie aplikacji u\uc0\u380 ywaj\u261 cej Spring Framework\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs24 \cf2 \cb3 \

\f1 \cf4 @RunWith\cf2 (SpringRunner.\cf6 class\cf2 )  \cf5 // spring ma wlasnego runnera testow\
\cf4 @SpringBootTest\
\cf6 public class \cf2 PrzykladowyProjektApplicationTests \{\
\
	\cf4 @Test\
	\cf6 public void \cf7 contextLoads\cf2 () \{\
	\}\
\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
@RunWith(SpringRunner.class)\
@SpringBootTest\
// dzieki 2 powyzszym adnotacja ejstesmy w stanie korzystac z kontekstu aplikacji wewnatrz tesu \
\
\
// ponizszy test sprawdza czy kontekst poprawnie sie laduje\
@Test\
public void contextLoads()\{\
\}\
\
// test metody to string\
@Autowired\
Knight knight; // bo knight to bean i mozemy go wstrzyknac\
\
@Autowired\
Castle castle; // bo Castle to bean I mozemy go wstrzyknac \
\
@Test\
public void testCastle()\{\
	String excepted = \'84Znajduje sie tutaj zamek o nazwie Castle Black. Zamieszkaly o rycerza\
		o imieniu Lancelot (29)\'94; // ogolnie jest to tekst ktory ma sie wyswietlic po wywolaniu metody toString\
\
	assertEquals(except, castle.toString());\
	\
\}\
\
// taki jak wyzej test jest wolny !!! -> 25 ms !!! \
// lepszy test (szybszy -> bez kontekstu Springowego) robiacy to samo:  //-> 3 ms !!!!!!!!!\
public class CastleTest\{\
\
	@Test\
	public void castleToStringMessage()\{\
		Quest quest = new Quest();\
		knight.setQuest(quest);\
		Knight knight = new Knight(); // w knight nie wstrzykiwac wieku i imienie tylko jako stale\
		Castle castle = new Castle(knight, \'84Castle Black\'94);  // musi bcc odpowiedni protected konstruktor\
	\
		String excepted = \'84Znajduje sie tutaj zamek o nazwie Castle Black. Zamieszkaly przez 			rycerza o imieniu Lancelot (29)\'94; // ogolnie jest to tekst ktory ma sie wyswietlic po 			wywolaniu metody toString\
\
			assertEquals(except, castle.toString());\
	\}\
\
\}\
\
//				AUTOMATYCZNE WYSZUKIWANIE KOMPONENT\'d3W\
\
\
1. Spring wyszukuje komponenty w g\uc0\u322 \'f3wnym katalogu aplikacji -> czyli w tym katalogu	w kt\'f3rym znajduje si\u281  g\u322 \'f3wna klasa aplikacji Springowej -> adnotacja 	@SpringBootApplication i poczonaj\u261 c od niego przeszukuje podkatalogi -> \
	jezeli utworzymy go w innym folderze to uzyskamy b\uc0\u322 \u261 d tworzenia kontekstu\
\
2. To domy\uc0\u347 lne zachowanie mo\u380 emy zmieni\u263  poprzez adnotacj\u281  \
@ComponentScan(\'84\'94) // gdzie \'84argumentem\'94 adnotacji jest paczka od kt\'f3rej \
// ma rozpocz\uc0\u261 \u263  si\u281  przeszukiwanie (doda\u263  now\u261  paczk\u281 )  -> adnotacj\u281  t\u261  umieszczamy tam gdzie jest klasa \
Z adnotacj\uc0\u261  @SpringBootApplication \
- adnotacja ta moze przyjmowac rowniez liste np. \
	@ComponentScan(\{\'84com.clockworkjava.kursspring\'94, com.clockworkjava.component\'94\})\
\
- gdy mamy wiele klas biznesowych i tylko kilka klas componentow w domyslnym katalogu \
Warto umiescic te komponenty w jednym katalogu po to by Spring odnalaz\uc0\u322  je wcze\u347 niej \
-> szybciej startowa\uc0\u322 \
\
 	-> istnieje 2 sposob dodawania komponentow do sciezki: \
		-> zamiast podawac paczki w annotacji mozna wpisac: \
			@ComponentScan(basePackageClasses = \{Starter.class, Castle.class\})\
\
\
//				KONFIGURACJA KOMPONENT\'d3W. ANNOTACJE\
\
-> w Springu wersji 4 sa 3 sposoby oznaczania komponentow:\
		1. Przez annotacje -> @Component ; wstrzykujemy @Autowired\
		 -> istnieja wariacje komponent\'f3w jak: \
			@Repository\
			@Service \
			@Controler\
//				KONFIGURACJA KOMPONENT\'d3W. XML\
\
2 sposob na konfiguracje komponentow -> najstarszy sposob \
	XML troche bardziej przejrzysty -> spotykany w wiekszych aplikacjach \
\
\pard\pardeftab720\partightenfactor0

\f3\fs30 \cf10 \cb11 \expnd0\expndtw0\kerning0
<?xml version="1.0" encoding="UTF-8"?>\cf12 \
\pard\pardeftab720\partightenfactor0
\cf13 <beans\cf12  \cf14 xmlns\cf12 =\cf15 "http://www.springframework.org/schema/beans"\cf12 \
       \cf14 xmlns:xsi\cf12 =\cf15 "http://www.w3.org/2001/XMLSchema-instance"\cf12 \
       \cf14 xsi:schemaLocation\cf12 =\cf15 "\
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"\cf13 >\
	\
	<!  - - glowny tag: \'97 >\
	<! - - odpowiednim @ComponentScan w XML jest zapisany ponizej \'97 > \
	<context:component-scan base-package = \'84com.clockworkjava\'94/>\
	<context:property-placeholder location=\'84class path: castle.properties\'94/> <! \'97 - ten tag - property jest po to by \
Byl dosten do odpowiedniego stringa \'97>\
	<bean id=\'84quest\'94 class=\'84com.clockworkjava.kursspring.domain.Quest\'94/>\
\
\
	<! \'97 tak wyglada inicjalizacja pol klasy  - - > \
	<bean id=\'84knight\'94 class=\'84com.clockworkjava.kursspring.domain.Knight>\
	<constructor-arg index=\'840\'94 value=\'84Lancelot\'94/>\
	<! - - Ustawia daje pierwszemu argumentow wartosc Lancelot;\
		 \'97 indeksy dotycza odpowiedniego konstruktora - >\
	<constructor-arg index=\'841\'94 value=\'8429\'94/>\
	\
	<! - - Ustawianie(warotosci pol) nie poprzez konstruktor a metode wstrzykujaca \'97 > \
\
		<property name=\'84quest\'94  ref=\'84quest\'94/>\
		<property name=\'84name\'94 value=\'84$\{my.castle.name:East Watch\}\'94/>\
	</bean>\
\
\
<!  - - by ustawic metode stora odpali sie tuz po utworzeniu obiektu ustawiamy argument init-method=\'84\'85\'94\'97>\
	<bean id=\'84castle\'94 class=\'84com.clockworkjava.kursspring.domain.Castle\'94 init-method=\'84build\'94 destroy-method=\'84tearDown\'94>\
// przed rym gdy zostanie zniszczony -> destroy-method=\'84..\'94\
\
	<constructor-arg inex=\'840\'94 ref=\'84knight\'94/>\
	\
\
</bean>\
\
\
</beans>\
\
\
Trzeba jeszcze zaladowac takiego xml\'92a\
Przez dodanie adnotacji do kalsy z adnotacja @SpringBootApplication\
\
@ImportResource(\'84classpath:config/spring-config.xml\'94)
\f0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 		spring-config.xml to nazwa a config katalog\
\
- mozna mieszac sposoby konfiguracji -> wszydstkie laduja w kontenerze\
\
<! - - w pokazany ponizej sposob importujemy inny plik do xml  - - >\
<import resource=\'84class path:config/castle-config.xml\'94/>\
\
//				KONFIGURACJA KOMPONENT\'d3W @Configuration\
\
 -> 3 spos\'f3b to konfiguracja za pomoc\uc0\u261  klasy konfiguracyjnej \
@Configuration // dzieki tej adnotacji Spring wie, \uc0\u380 e klasa ta zawiera definicje beanow\
@ImportResource(\'84classpath:config/castle-confi.xml\'94) // mozemy tez importowac pliki \
// konfiguracyjne XML do klasy\
public class MainConfig\{\
	\
	// ta klasa musi znajdowac sie na sciezce komponentow store sa przeszukiwane pod k\uc0\u261 tem beanow\
\
	@Bean\
	public Quest createQuest()\{\
		// to co dana metoda zwroci -> traktowane jako bean\
		return new Quest();\
	\}\
	\
	@Bean\
	public Knight createKnight()\{\
		Knight knight = new Knight();\
		\
		knight.setQuest( createQuest() ); // tu wstrzykujemy beana\
		return knight;\
	\}\
\
\}\
\
\
// mozemy wstrzyknac klase konfiguracyjna do innej przy pomocy adnotacji \
@Import(MainConfig.class)\
\
// 					Ktory sposob konfiguracji wybrac?\
\
-> kazdy projekt zaczynac od adnotacji @Component/@Autowired w roznych odmianach\
-> komponenty zewnetrzne -> wtedy klasy konfiguracyjne np. DataSource jest klasa zewnetrzna\
-> XML -> gdy mamy do czynienia ze starszymi aplikacjami (gdy XML byl glownym sposbem\
Tworzenia aplikacji)\
\
//				WZORZEC Singleton\
// klasy bezstanowe to klasy ktore zwieraja tylko metody statycznej (Utils) \
// czesto opatrzone sa annotacja @Singleton -> wtedy na JVM tylko jedna \
// instancja sie znajduje\
\
\
// ponizsza klasa ma problemy jezeli chodzi o Serializacje czy wielowatkowosc\
public class PersonUtils\{\
	\
	PersonUtils instance = null;\
	\
	// nie mozna stworzyc\
	private PersonUtils()\{\
\
	\}\
	\
	public PersonUtils getInstance()\{\
		if(instance == null)\{\
			instance = new PersonUtils();\
		\}\
\
		return instance;\
	\}\
\
\
	\
\
\
\}\
\
\
// prawidlowe tworzeniee: \
// sama Java zapewni ze bedzie to Singleton\
public enum PersonUtils2\{\
	INSTANCE:\
	\
	public final String operacja(Person person)\{\
		return person.name.toUpperCase();\
	\}\
\
\}\
\
\
// Stany to po prostu pola klasy\
\
\
//					Bean @Scope\
- domyslnie zasieg kazdego beana jest ustawiony na Singleton -> \
Bean ma dokladnie jedna instancje i wlasnie ona jest wstrzykiwana za kazdym razem jako \
Zaleznosc -> dlatego gdy jakas klasa w ktorej jest wstrzyknieta zmieni stan tego beana to \
Ta zmiana jest widziana w innych klasach do ktorych jest ona wstrzyknieta\
\
- oczywiscie mozna temu zaradzic bo istnieje drugi scope zwany prototype\
@Component\
@Scope(\'84singleto\'94) // nawet jakby tego nie bylo to wtedy ta klasa jest domyslnie singletonem\
\
// zeby to zmienic: \
@Component\
@Scope(\'84prototype\'94) // za kazdym razem gdy dany bean jest wstrzykiwany do innej klasy\
// to jest tam wstrzykiwana jej nowa instacja\
\
// zeby zmienic Scope w klasie konfiguracyjnej (oznaczonej annotacja @Configuration)\
// dodajemy pod @Bean annotacje @Scope(\'84prototype\'94)\
\
w xml jazzy bean ma atrubut scope = \'84prototype\'94/\'84singleton\'94\
\
- mamy 5 typow Scopow -> pozostale 3 dotycza juz aplikacji Webowych\
\
//					WSTRZYKIWANIE BEANOW TEGO SAMEGO TYPU\
\
// co zrobic gdy chcemy miec 2  roznych rycerzy(class Knight) jako komponenty a nie \
// kolejne instancje tego\
\
-> nie da sie tego zrobic z poziomu adnoatcji @Component czy @Scope\
\
-> mozemy w klasie konfiguracyjnej np skopiowac:  -> jednak spowoduje to \
-> blad -> mamy 2 beany tego samego typu !!! Bo gdy chcemy potem wstrzyknac rycerza\
-> z kontenera -> to blad \'85 \
\
@Configuration\
public class MainConfig\{\
	\
	@Autowired\
	Quest quest;\
	\
	@Bean(name=\'84lancelot\'94)\
	public Knight lancelot()\{\
		Knight lancelot = new Knight(\'84Lancelot\'94, 29);\
		lancelot.setQuest(quest);\
		return lancelot;\
	\}\
\
	@Bean(name=\'84persival\'94)\
	public Knight createKnightBean()\{\
		Knight persival = new Knight(\'84Persival\'94, 29);\
		persival.setQuest(quest);\
		return persival;\
	\}\
	\
\
\
\}\
\
// adnotacja @Qualifier(value=\'84lancelot\'94) -> przy parametrze konstruktora\
// w adnotacji tej podajemy nazwe konkretnego Beana, ktorego chcemy wstrzyknac\
// \
\
// do Castle jest wstrzykiwany rycerz\
@Autowired\
public Castle(@Qualifier(value=\'84lancelot\'94)Knight knight)\{\
	this.knight = knight;\
\
\}\
\
\
\
// annotacja Qualifier more bye rowniez przed polem, ktore jest wstrzykiwane np. \
// w ponizszej klasie wstrzykujemy  ( rozniej od Castle) wstrzykujemy konkretne pole: \
@Autowired\
@Qualifier(value = \'84percival\'94)\
Knight knight;\
\
// mozn tez beany skonsuowac przez XML -> ustawiajac odpowiednie\
// id w beanach\
\
// XML nie moze wstrzykiwac bezposrednio do pol\
\
// adnotacja @Primary\
// -> ustawiamy jednego z powtarzajacych sie Beanow tak i powodujemy wtedy ze \
// gdy nie podamy Qualifier to nie przekreci sie (crash) kontekstu (Springa/apki)\
\
// robimy to jak nizej \
\
@Configuration\
public class MainConfig\{\
	\
	@Autowired\
	Quest quest;\
	\
	@Bean(name=\'84lancelot\'94)\
	@Primary\
	public Knight lancelot()\{\
		Knight lancelot = new Knight(\'84Lancelot\'94, 29);\
		lancelot.setQuest(quest);\
		return lancelot;\
	\}\
\
	@Bean(name=\'84persival\'94)\
	public Knight createKnightBean()\{\
		Knight persival = new Knight(\'84Persival\'94, 29);\
		persival.setQuest(quest);\
		return persival;\
	\}\
	\
\}\
\
\
// efetk primary mosey rowniez uzyskac xml-em \
// dodajemy do bean atrybut primary=\'84true\'94\
\
\
//							WSTRZYKIWANIE KOLEKCJI\
\
public class Tournament\{\
	@Autowired\
	@Qualifier(value = \'84percival\'94)\
	List<Knight> knights; // oczywiscie Knight to bean\
\
\
	// metoda mutujaca\
	public void setKnight(List<Knight> knights)\{\
		this.knights = knights;	\
	\}\
\
\
// tutaj wstrzyknelo sie bez problemu. ..\
\
\}\
\
// dla Set -> tez bedzie dzialac\
public class Tournament\{\
	@Autowired\
	@Qualifier(value = \'84percival\'94)\
	Set<Knight> knights; // oczywiscie Knight to bean\
\
\
	// metoda mutujaca\
	public void setKnight(Set<Knight> knights)\{\
		this.knights = knights;	\
	\}\
\
\
// tutaj wstrzyknelo sie bez problemu. .. -> \
// jednak jak mamy Set to jak obiekty beda mialy taki sam Hash i equals to nie zostana wstrzykniete duplikaty\
\}\
\
// jezeli chcemy pewien podzbior wszystkich beanow Knight: -> najlepiej XML\
// Mapy nie jesesmy w stanie wstrzyknac - > XML \
// np. Jezeli chcemy wstrzyknac do klasy Tournament: \
<bean id=\'84tournament\'94  class=\'84com.clockworkjava.kursspring.domain.Tournament\'94>\
	<property name=\'84knights\'94>\
		<list>\
			<!\'97 tu podajemy nazwy beanow ktore chcemy wstezykiwac \'97>\
			<!\'97 sztuczne klasy -> zla metoda!!!\'97>\
			<ref bean=\'84percival\'94/>\
			<ref bean=\'84lancelot\'94/>\
			<!\'97 jesli Set to znacznik <set> \'85</set> \'97>\
			<!\'97 jesli 2 beany sa sobie rowne -> to wstrzykniety zostanie tylko jeden \'97>\
		</list>\
	</property>\
</bean>\
\
// w przypadku \
\
//@Autowired\
//Map<String, Knight> knights;\
To normlnie w XML :\
\
<bean id=\'84tournament\'94  class=\'84com.clockworkjava.kursspring.domain.Tournament\'94>\
	<property name=\'84knights\'94>\
		<map>	\
			<entry key=\'84Lancelot\'94 value-ref=\'84Lancelot\'94/>\
			<!\'97 .. . . .\'97>\
		</map>\
	</property>\
</bean>\
\
\
\
// 						CO POWINNO BYC BEANEM?\
\
-> wiele instancji np. Wielu rycerzy (dane przekazywane przez uzytkownika) -> rycerz to \
	nie powinien byc komponent\
-> zapisywanie/usuwanie obiektu domenowego -> nazywamy repozytoriami \
-> Spring oferuje annotacje @Repository -> robi to samo co komponent ale \
	jest ona uzywana dla programistow by wiedzieli ze jest to klasa odpowiedzialna\
	za zapisywanie/odczytywanie do pamieci/ bazy danych\
\
-> annotacja @Service -> klasy bezstanowe, komponenty springowe,\
	zestaw publicznych metod oblusgujacych czesc operacji biznesowych, \
	znowu przeznaczona bardziej dla programisty\
\
\
//					TASK SCHEDULER\
\
@EnableScheduling  dodana na poczatku klasy bedacej SpringBootem powopduje \
Zainicjalizowanie task schedulera (cos jak timer) \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
@Scheduled(fixedDelay = 1000) // powoduje ze ta metoda b\uc0\u281 dzie wykonywana co sekunde\
// fixedDealy dopiero po zakonczeniu calej metody czeka sekunde\
public void createRandomQuest()\{\
// \'85 \
\}\
-> uwaga!!! Aplikacja nie zamyka sie recznie bo caly czas dziala scheduler\
@Scheduled(fixedRate=1000) //teraz sekunda jest liczona od momentu wywolania metody \
\
@Scheduled(fixedRate = 1000, initialDelay = 3000)\
// initialDelay okresla po jakim czasie dana metoda ma zaczac sie wykonywac\
\
Taka annotacje mozemy rowniez parametryzowac stringiem przykladowo:\
Jezeli mamy jakis string okreslajacy wartosc w xml to wtedy: \
@Scheduled(fixedDelayString =\'84$\{stringZXML\}\'94)\
\
\'85 konfiguracja schedulera w XML: \
<task:scheduler id=\'84myScheduler\'94 pool-size=\'8410\'94/>\
\
// pool-size mowi (prawie) ile metod moze jednoczesnie byc obslugiwanych (?)\
\
// utworzenie zadania (w XML):\
<task:scheduled-tasks>\
	<task:scheduled ref=\'84questRepository\'94 method=\'84createRandomQuest\'94 fixed-rate=\'841000\'94/>\
</task:scheduled-tasks>\
// ref to klasa w ktorej znajduje sie metoda do wywolania co jakis czas\
// method -> nazwa metody\
// fixed-rate -> czas co jaki ma byc ona uruchamiana\
\
\
//					WZORZEC STRATEGII\
\
We wzorcu strategii chodzi o to by rozdzielic to co robi od tego w jaki sposob to robimy\
// chodzi o to by wsztrzyknac dynamicznie to jak cos zrobic -> np. jak sortowac liczby\
\
// Profil springowy okresla zestaw Beanow, ktory zostanie wlasnie w danym profilu np. \
// przy starcie aplikacji\
@Profile(\'84dev\'94) -> dodajemy przed definicja odpowiednich beanow\
@Profile(\'84prod\'94)\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf16 \cb17 @Bean\cf18 (\cf19 name \cf18 = \cf20 "DbKnightRepository"\cf18 )\
\cf16 @Profile\cf18 (\cf20 "prod"\cf18 )\
\cf21 public \cf18 KnightRepository \cf22 createDbKnightRepository\cf18 ()\{\
    \cf21 return new \cf18 DbKnightRepository()\cf21 ;\
\cf18 \}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf6 \cb3 spring.profiles.active \cf5 = \cf9 prod\cf20 \cb17 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
\
To samo mo\uc0\u380 emy zrobi\u263  w XML -> \
Znacznik beans posiada atrybut profile np. <beans profile=\'84dev\'94 \'85\
\
//						SPRING MVC\
\
Tak jak zawsze -> wzorzec architektoniczny \
\
Controller -> praise widok I model \
View -> klikniety guzik -> przekazuje do Cotnroller (controller analizuje i przesyla do Modelu)\
	Model zwraca dane -> zwraca kontrolerowi -> kontroler tworzy strone\
\
// w Springu: \
1. Kazdy request trafia do FrontContorollera (tez wzorzec projektowy) -> w Springu nazywany\
	Dispatcher Servlet -> jego zadaniem jest przeslanie do odpowiedniego kontrolera\
2. Handler Mapping -> przesylany Request I handler na podstawie danych z requesta \
		jest w stanie wskazac konkretny controller -> zwraca taka informacje do Dispatcher 		Servlet\
3. Controller \'84rozbiera\'94 request -> parametry, metadane \'85 \
		// uwaga !! Spring ma kilka Controllerow\
4. Controller przesyla zadania do odpowiednich komponentow odpowiedzialnych za \
	logik\uc0\u281  biznesowa\
5. Po przetworzeniu idzie do Controllera z ktorego idzie widok do utworzenia do \
	Dispatcher Servleta -> idzie do View Resolvera(jest on w stanie wskazac \
		konkretna sciezke gdzie dany widok jest) -> potem zwroca odpowiedni \
		View ktory jest tworzony.\
\
//					HELLO SPRING MVC\
\
Dodawanie webowej strony springa: \
<dependency>\
	<groupId>org.springframework.boot</groupId>\
	<artifactId>spring-boot-starter-web</artifactId>\
</dependency>\
\
Adnotacja @Controller powoduje ze dana klasa staje sie kontrolerem\
Localhost:8080 -> domyslny link TomCata\
\
Po tym nalezy zamapowac odpowiedni request dla przegladarki \
@RequestMapping(\'84/hello\'94) // obsluguje request hello\
public String hello()\{\
	return \'84hellospring.html\'94; // to jest HTML \
\}\
\
// domyslnie statyczne strony html umieszczamy w resources w podkatalogu srtatic \
I naywamy odpowiednia nazwa \'85 np. tutaj  helloworld.html\
\
\
//				THYMELEAF I PRACA Z MODELEM\
\
\
Controller jest komponentem Front-Endowym kontroluj\uc0\u261 cym widok i model \
Repozytorium jest komponentem ktory ma za zadanie komunikowac sie z baz danych \
-> lepiej nie mieszac tych dwoch elementow \
-> warto mieszy nimi umiescic Service\
\
Dane z kilku widokow -> DTO (Data Transfer Object)\
\
//\'85.\
Przyklad przekazywania modelu do odpowiedniej metody: \
@RequestMapping(\'84/knight\'94)\
public String getKnight(Model model)\{\
	//knightService to wstrzykniety  odpowiedni Service \
	List<Knight> allKnights = knightService.getAllKnights();\
	model.addAttribute(\'84knights\'94, allKnights);\
	return \'84knights\'94; // juz bez rozszerzenia .html bo to templatka dynamiczna\
\}\
\
\
//  zeby widok mogl cos zrobic z modelem mozemy uzyc jakis silnik \'84templatek\'94 \
// np. JSP czy Thymleaf (powiazany ze Springiem)\
\
// -> dodawanie go do xml: \
<dependency>\
		<groupId>org.springframework.boot</groupId>\
		<artifactId>spring-boot-starter-thymelead</artifactId>\
</dependency>\
\
Domyslnie strony thymeleafa laduja w resources -> templates \
\
@RequestMapping(\'84/knight\'94)\
public String getKnight(Model model)\{\
	//knightService to wstrzykniety  odpowiedni Service \
	List<Knight> allKnights = knightService.getAllKnights();\
	model.addAttribute(\'84knights\'94, allKnights);\
	model.addAttribute(\'84hello\'94,\'94Witaj \uc0\u347 wiecie\'94); // potem z takiego atrybutu mozemy\
	// odpowiednio skorzystac w html i wyswietlic na stronie\
	return \'84knights\'94; // juz bez rozszerzenia .html bo to templatka dynamiczna\
\}\
\
<p th:text=\'84$\{hello\}\'94/>\
\
\
// obiekty (lista) ; \
<div th:each=\'84knight : $\{knights\}\'94>\
	<p th:text=\'84$\{knight\}\'94/>\
</div>\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf23 \cb17 <table>\
    <thead>\
        <tr>\
            <td>\cf18 \cb17 Imie rycerza\cf23 \cb17 </td>\
            <td>\cf18 \cb17 Wiek\cf23 \cb17 </td>\
        </tr>\
    </thead>\
    <tbody \cf24 th\cf25 :each=\cf26 "knight : $\{knights\}"\cf23 >\
        <tr>\
            <td \cf24 th\cf25 :text=\cf26 "$\{knight.name\}"\cf23 />\
            <td \cf24 th\cf25 :text=\cf26 "$\{knight.age\}"\cf23 />\
        </tr>\
    </tbody>\
</table>\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
\
 \
\
	\
\
\
\
\
\
\
\
\
\
\
\
 }