{\rtf1\ansi\ansicpg1250\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red153\green168\blue186;\red32\green32\blue32;\red173\green169\blue32;
\red109\green109\blue109;\red191\green100\blue38;\red254\green187\blue91;\red133\green96\blue154;\red88\green118\blue71;
\red107\green0\blue1;\red246\green246\blue246;\red38\green38\blue38;\red50\green109\blue108;\red106\green0\blue108;
\red29\green0\blue255;\red197\green195\blue255;\red225\green179\blue88;\red172\green172\blue172;\red149\green184\blue79;
}
{\*\expandedcolortbl;;\csgenericrgb\c60000\c65882\c72941;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c67843\c66275\c12549;
\csgenericrgb\c42745\c42745\c42745;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c99608\c73333\c35686;\csgenericrgb\c52157\c37647\c60392;\csgenericrgb\c34510\c46275\c27843;
\cssrgb\c50196\c0\c0;\cssrgb\c97255\c97255\c97255;\cssrgb\c20000\c20000\c20000;\cssrgb\c24706\c49804\c49804;\cssrgb\c49804\c0\c49804;
\cssrgb\c16471\c0\c100000;\csgenericrgb\c77255\c76471\c100000;\csgenericrgb\c88235\c70196\c34510;\csgenericrgb\c67451\c67451\c67451;\csgenericrgb\c58431\c72157\c30980;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww11880\viewh7940\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
Notes took by me during doing course:\
		
\b\fs28 https://strefakursow.pl/kursy/programowanie/kurs_spring_framework_od_podstaw.html\
\

\b0 JPA -> zapisywanie i odczyt danych z bazy danych\
\
			SPRING BOOT\
Spring -> framework do tworzenia stron internetowych -> Dost\uc0\u281 pny r\'f3wnie\u380 \
Dla j\uc0\u281 zyk\'f3w pokrewnych -> Groovy, Kotlin (<3)\
\
- powsta\uc0\u322  jako alternatywna EJB (Enterprise Java Bean)\
\
- Spring Boot ->podzia\uc0\u322  modu\u322 \'f3w an paczki - \'82startery\'92 np. \'82spring-web-starter\'92 i \
Zarz\uc0\u261 dzanie wersjami ka\u380 dego z nich tak by nie dochodzi\u322 o do konfilkt\'f3w + autokonfiguracja + wbudowany serwer webowy (domy\u347 lnie Tomcat)\
\
\
Niezbedne narzedzia: \
	-> JDK jak zawsze\
	-> Maven \
\
// 			wygenerowanie projektu Spring Boot\
\
\
start.spring.io -> aplikacja webowa s\uc0\u322 u\u380 \u261 ca do wygenerowania aplikacji spring bootowych\
\
Group -> np. Firma\
Artefact -> nazwa projektu \
Dependencies -> zaleznosci np. Web (troche jak w Android Studio ? )\
\
//			przeglad plikow projektu\
\
.idea -> pliki polaczone z projektem w IDE InteliJ \
.mvn -> katalog gdzie .jar mavena i properties -> po to by w polaczeniu z mvnw mvnm.cmd kazy kto nie ma mavena mogl ten projekt odpalic\
\
src -> pliki zrodlowe jak i testowe\
\
.gitgnore -> git \
\
PrzykladowyProjekt.iml -> sklada caly projekt w calosc\
\
mvnm.cmd  i mvnw -> pliki skryptowe \
\
\
pom.xml -> plik zawierajacy konfiguracje Mavena -> WAZNE !!!\
\
		<groupId>\
		<version>\
		<packaging>\
		<name> -> nazwa projektu (generalnie dla ludzi)\
<properties> -> ustawienia projektu \
\
<dependencies> -> zaleznosci \
\
W src: 	\
		main -> logika\
			java -> pliki zrodlowe\
			resources -> application.properties -> propertiesy np. Adres bazy danych zwiazane z wewnetrznym dzialaniem (pom.xml jest og\'f3lnie dla Mavena)\
		test -> testy\
\
//				HELLO WORLD\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 CommandLineRunner\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 - interfejs CommandLineRunner (z metoda public void run(String\'85 args) throws Exception -> metoda ktora zostanie wywolana jak tylko Spring zakonczy swoja konfiguracje\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs24 \cf2 \cb3 \

\f1 \cf4 @Component \cf5 // klasa jest SpringBeanem\
\cf6 public class \cf2 Hi \cf6 implements \cf2 CommandLineRunner \{\
\
    \cf4 @Override\
    \cf6 public void \cf7 run\cf2 (String ... args) \cf6 throws \cf2 Exception\{\
\
        System.
\f2\i \cf8 out
\f1\i0 \cf2 .println(\cf9 "Hello world!!!"\cf2 )\cf6 ;\
        \
    \cf2 \}\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
/// 			fundamenty Spring Framework:\
\
	- Wstrzykiwanie zale\uc0\u380 no\u347 ci (Dependency Injection)\
	- Spring beans\
	- DI + Beans \
	- testowanie komponent\'f3w\
\
//		Wstrzykiwanie zale\uc0\u380 no\u347 ci (Dependency Injection) -> prostsze niz myslalem XD ;) \
\
Wstrzykiwanie to gdy w jakiejs klasie mamy pole reprezentujace jakis obiekt \
i do konstruktora takiej klasy przekazujemy obiekt odpowiedniego typu np. \
Quest quest = Quest(\'84Zabij smoka\'94) ; \
\
Knight knight1 = new Knight(\'84Tomek\'94, \'8420\'94, quest); // tutaj nastepuje wstrzykiwanie\
\
\
// sa w rodzaje wstrzykiwania: \
	-> przez konstruktor\
	-> przez metode ( najczesciej settera np. setQuest(Quest quest) -> moze byc problem z nullem \
\
Quest quest = Quest(\'84Zabij smoka\'94) ; \
\
Knight knight1 = new Knight(\'84Tomek\'94, \'8420\'94);\
knight1.setQuest(quest);\
\
\
//			Spring Beans, Kontekst, Kontener\
\
Spring Bean -> zwykle klasy Javy oznaczone odpowiedzni\uc0\u261  adnotacj\u261  (@Component) lub skonfigurowanie odpowiednio w XML \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf4 \cb3 @Component\
\cf6 public class \cf2 Castle \{\
\
    \cf6 private \cf2 String \cf8 name \cf2 = \cf9 "East Watch"\cf6 ;\
\
    public \cf7 Castle\cf2 ()\{\
\
    \}\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 // gdy spring bedzie startowal to doda taka klase do kontenera\
Kontener -> mapa klucz -> klasa  a wartosc -> instancja tej klasy\
Przy starcie jest tworzona nowa instancja klasy Castle (Beansa) i dodawana \
Do kontekstu -> jest w\'f3wczas gotowa do u\uc0\u380 ycia \
Czyli pod nazw\uc0\u261  \'84castle\'94 mamy instancje klasy Castle\
-> gdy aplikacja ko\uc0\u324 czy dzia\u322 anie aplikacja daje informacje kontenerowi zeby zniszczyl \
Beany i dopiero wtedy aplikacja konczy dzialanie \
\
-> kontener i \'84kilka uzytecznych funkcjonalnosci\'94 przechowywanych jest w Kontekscie -	> jest on przeszukiwany przez Springa pod kontem Beans\'f3w (@Component)\
\
-> metoda run ze Startera po zaladowaniu Beans\'f3w uzyskuje dost\uc0\u281 p do wszystkich klas implementuj\u261 cych interfejs CommandLineRunner i uruchamia ich metod\u281  run \
(String \'85 strings)\
\
//			cykla \uc0\u380 ycia Sptring Beans\
\
Mo\uc0\u380 emy zareagowa\u263  programistycznie na \'84utworzenie\'94 i \'84zniszczenie\'94 Beana \
\
- uzywamy do tego odpowiednich adnotacji: \
	\
	@PostConstruct\
	public void build()\{\
		System.out.println(\'84Wlasnie stworozono obiekt!\'94);\
	\}\
\
	@PreDestroy\
	public void tearDown()\{\
		System.out.println(\'84Wlasnie zniszcono obiekt!\'94);\
	\}\
\
//			wstrzykiwanie zale\uc0\u380 no\u347 ci + Spring Beans\
\
Z kontekstu springowego mozemy pobierac beany: \
\
\
Metoda run() \
\
Zwraca ConfihurableApplicationContext -> Mona go przypisac do referencji a nastepnie, wywolujac metode\
refCtx.getBean(\'84odpowiedniaNazwaBeana\'94); mozna uzyskac odpowiedniego Beana\
\
	
\f1\fs24 \cf6 \cb3 package \cf2 com.example.tomek.PrzykladowyProjekt\cf6 ;\
\
import \cf2 com.example.tomek.PrzykladowyProjekt.domain.Castle\cf6 ;\
import \cf2 org.springframework.boot.SpringApplication\cf6 ;\
import \cf2 org.springframework.boot.autoconfigure.\cf4 SpringBootApplication\cf6 ;\
import \cf2 org.springframework.context.ConfigurableApplicationContext\cf6 ;\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf4 @SpringBootApplication \cf5 // oznacza ze jest to glowna klasa startowa dla naszej\
// aplikacji\
\cf6 public class \cf2 PrzykladowyProjektApplication \{\
\
	\cf6 public static void \cf7 main\cf2 (String[] args) \{\
\
\
		ConfigurableApplicationContext ctx=SpringApplication.
\f2\i run
\f1\i0 (PrzykladowyProjektApplication.\cf6 class, \cf2 args)\cf6 ;\
\
		\cf2 Castle castle=(Castle)ctx.getBean(\cf9 "castle"\cf2 )\cf6 ;\
\
        \cf2 System.
\f2\i \cf8 out
\f1\i0 \cf2 .println(castle)\cf6 ;\
\
	\cf2 \}\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
// ALE MAMY LEPSZE METODY:\
\
	ale mozna zrobic:\
	1. Zmienna referencyjna odpowiedniego typu (np. Castle) w danej klasie\
	we wnetrzu ktorej znajduje sie metododa run z ktorej chcielibysmy uzyskac dostep 	do odpowiedniego beana nalezy oznaczyc jak nizej:\
	\
	@Autowired // tylko dla klas oznaczonych adnotacja @Component -> Beansow !!! -> bo musi byc przeciez w Kontenerze !!! -> jak 2 benay tej samej klasy ale pod inna nazwa to tez blad !!!\
	Castle castle; // dzieki temu gdy spring buduje ta klase to odszuka nam castle i wstrzyknie -> mozemy go uzyc \
\
//				Wstrzykiwanie typ\'f3w prymitywnych\
\
Do wstrzykiwania typ\'f3w prymitywnych s\uc0\u322 u\u380 y adnotacja \
@Value(\'84jakasWartoscOdpowiedniegoTypu\'94)\
\
@Value(\'84Lancelot\'94)\
private String name;\
\
@Value(\'8429\'94) // mimo ze wpisujemy Stringa to pod spodem jest parsowanie do int\
private int age;\
\
 Ale takie wstrzykiwanie to rzadko\uc0\u347 \u263 \
private String name = \'84Lancelot\'94;\
\
private int age = 27;\
\
cz\uc0\u281 stszym zastosowaniem adnotacji @Value jest wstrzykiwanie zawarto\u347 ci, kt\'f3r\u261  podali\u347 my w application.properties\
\
application.properties -> przechowuje propertiesy aplikacji \
\
np. Mozemy stworzyc \
my.castle.name=East Watch\
\
// . . .. teraz w klasie np.  Castle \
@Value(\'84$(my.castle.name))\
private String name; // tutaj wstrzykujemy properties\'92a\
// podawanie wartosci domyslnej ( gdyby nie.bylo danego propertiesa): \
@Value(\'84$(my.castle.name:East Watch)\'94)\
private String name;\
\
jezeli chcemy stworzyc wlasny plik propertiesow (oczywiscie w katalogu resources) to \
Musimy dodac odpowiedni\uc0\u261  adnotacje @PropertySource(\'84classpath:NazwaPlikuZProperties\'94)\
\
//			Rodzaje wstrzykiwania zale\uc0\u380 no\u347 ci w Spring Framework\
\
@Authowired -> 3 typ wstrzykiwania przez reflection API \
\
Mozna np. Wstrzykiwac rowniez do metody: \
@Autowired 	// tutaj wstrzykujemy rycerza\
public Castle(Knight knight)\{ // konstruktor\
	this.knight = knight; 	// knight to pole odpowiedniego typu\
\}\
\
\
- zeby wstrzykiwac do metody wystarczy tez dopisac adnotacje @Autowired\
public void setQuest(Quest quest)\{ // quest jest wstrzykiwany  -> setQuest to metoda wstrzykujaca\
	this.quest = quest; // quest to odpowiednie pole klasy\
\}\
\
//			testowanie aplikacji u\uc0\u380 ywaj\u261 cej Spring Framework\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs24 \cf2 \cb3 \

\f1 \cf4 @RunWith\cf2 (SpringRunner.\cf6 class\cf2 )  \cf5 // spring ma wlasnego runnera testow\
\cf4 @SpringBootTest\
\cf6 public class \cf2 PrzykladowyProjektApplicationTests \{\
\
	\cf4 @Test\
	\cf6 public void \cf7 contextLoads\cf2 () \{\
	\}\
\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
@RunWith(SpringRunner.class)\
@SpringBootTest\
// dzieki 2 powyzszym adnotacja ejstesmy w stanie korzystac z kontekstu aplikacji wewnatrz tesu \
\
\
// ponizszy test sprawdza czy kontekst poprawnie sie laduje\
@Test\
public void contextLoads()\{\
\}\
\
// test metody to string\
@Autowired\
Knight knight; // bo knight to bean i mozemy go wstrzyknac\
\
@Autowired\
Castle castle; // bo Castle to bean I mozemy go wstrzyknac \
\
@Test\
public void testCastle()\{\
	String excepted = \'84Znajduje sie tutaj zamek o nazwie Castle Black. Zamieszkaly o rycerza\
		o imieniu Lancelot (29)\'94; // ogolnie jest to tekst ktory ma sie wyswietlic po wywolaniu metody toString\
\
	assertEquals(except, castle.toString());\
	\
\}\
\
// taki jak wyzej test jest wolny !!! -> 25 ms !!! \
// lepszy test (szybszy -> bez kontekstu Springowego) robiacy to samo:  //-> 3 ms !!!!!!!!!\
public class CastleTest\{\
\
	@Test\
	public void castleToStringMessage()\{\
		Quest quest = new Quest();\
		knight.setQuest(quest);\
		Knight knight = new Knight(); // w knight nie wstrzykiwac wieku i imienie tylko jako stale\
		Castle castle = new Castle(knight, \'84Castle Black\'94);  // musi bcc odpowiedni protected konstruktor\
	\
		String excepted = \'84Znajduje sie tutaj zamek o nazwie Castle Black. Zamieszkaly przez 			rycerza o imieniu Lancelot (29)\'94; // ogolnie jest to tekst ktory ma sie wyswietlic po 			wywolaniu metody toString\
\
			assertEquals(except, castle.toString());\
	\}\
\
\}\
\
//				AUTOMATYCZNE WYSZUKIWANIE KOMPONENT\'d3W\
\
\
1. Spring wyszukuje komponenty w g\uc0\u322 \'f3wnym katalogu aplikacji -> czyli w tym katalogu	w kt\'f3rym znajduje si\u281  g\u322 \'f3wna klasa aplikacji Springowej -> adnotacja 	@SpringBootApplication i poczonaj\u261 c od niego przeszukuje podkatalogi -> \
	jezeli utworzymy go w innym folderze to uzyskamy b\uc0\u322 \u261 d tworzenia kontekstu\
\
2. To domy\uc0\u347 lne zachowanie mo\u380 emy zmieni\u263  poprzez adnotacj\u281  \
@ComponentScan(\'84\'94) // gdzie \'84argumentem\'94 adnotacji jest paczka od kt\'f3rej \
// ma rozpocz\uc0\u261 \u263  si\u281  przeszukiwanie (doda\u263  now\u261  paczk\u281 )  -> adnotacj\u281  t\u261  umieszczamy tam gdzie jest klasa \
Z adnotacj\uc0\u261  @SpringBootApplication \
- adnotacja ta moze przyjmowac rowniez liste np. \
	@ComponentScan(\{\'84com.clockworkjava.kursspring\'94, com.clockworkjava.component\'94\})\
\
- gdy mamy wiele klas biznesowych i tylko kilka klas componentow w domyslnym katalogu \
Warto umiescic te komponenty w jednym katalogu po to by Spring odnalaz\uc0\u322  je wcze\u347 niej \
-> szybciej startowa\uc0\u322 \
\
 	-> istnieje 2 sposob dodawania komponentow do sciezki: \
		-> zamiast podawac paczki w annotacji mozna wpisac: \
			@ComponentScan(basePackageClasses = \{Starter.class, Castle.class\})\
\
\
//				KONFIGURACJA KOMPONENT\'d3W. ANNOTACJE\
\
-> w Springu wersji 4 sa 3 sposoby oznaczania komponentow:\
		1. Przez annotacje -> @Component ; wstrzykujemy @Autowired\
		 -> istnieja wariacje komponent\'f3w jak: \
			@Repository\
			@Service \
			@Controler\
//				KONFIGURACJA KOMPONENT\'d3W. XML\
\
2 sposob na konfiguracje komponentow -> najstarszy sposob \
	XML troche bardziej przejrzysty -> spotykany w wiekszych aplikacjach \
\
\pard\pardeftab720\partightenfactor0

\f3\fs30 \cf10 \cb11 \expnd0\expndtw0\kerning0
<?xml version="1.0" encoding="UTF-8"?>\cf12 \
\pard\pardeftab720\partightenfactor0
\cf13 <beans\cf12  \cf14 xmlns\cf12 =\cf15 "http://www.springframework.org/schema/beans"\cf12 \
       \cf14 xmlns:xsi\cf12 =\cf15 "http://www.w3.org/2001/XMLSchema-instance"\cf12 \
       \cf14 xsi:schemaLocation\cf12 =\cf15 "\
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"\cf13 >\
	\
	<!  - - glowny tag: \'97 >\
	<! - - odpowiednim @ComponentScan w XML jest zapisany ponizej \'97 > \
	<context:component-scan base-package = \'84com.clockworkjava\'94/>\
	<context:property-placeholder location=\'84class path: castle.properties\'94/> <! \'97 - ten tag - property jest po to by \
Byl dosten do odpowiedniego stringa \'97>\
	<bean id=\'84quest\'94 class=\'84com.clockworkjava.kursspring.domain.Quest\'94/>\
\
\
	<! \'97 tak wyglada inicjalizacja pol klasy  - - > \
	<bean id=\'84knight\'94 class=\'84com.clockworkjava.kursspring.domain.Knight>\
	<constructor-arg index=\'840\'94 value=\'84Lancelot\'94/>\
	<! - - Ustawia daje pierwszemu argumentow wartosc Lancelot;\
		 \'97 indeksy dotycza odpowiedniego konstruktora - >\
	<constructor-arg index=\'841\'94 value=\'8429\'94/>\
	\
	<! - - Ustawianie(warotosci pol) nie poprzez konstruktor a metode wstrzykujaca \'97 > \
\
		<property name=\'84quest\'94  ref=\'84quest\'94/>\
		<property name=\'84name\'94 value=\'84$\{my.castle.name:East Watch\}\'94/>\
	</bean>\
\
\
<!  - - by ustawic metode stora odpali sie tuz po utworzeniu obiektu ustawiamy argument init-method=\'84\'85\'94\'97>\
	<bean id=\'84castle\'94 class=\'84com.clockworkjava.kursspring.domain.Castle\'94 init-method=\'84build\'94 destroy-method=\'84tearDown\'94>\
// przed rym gdy zostanie zniszczony -> destroy-method=\'84..\'94\
\
	<constructor-arg inex=\'840\'94 ref=\'84knight\'94/>\
	\
\
</bean>\
\
\
</beans>\
\
\
Trzeba jeszcze zaladowac takiego xml\'92a\
Przez dodanie adnotacji do kalsy z adnotacja @SpringBootApplication\
\
@ImportResource(\'84classpath:config/spring-config.xml\'94)
\f0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 		spring-config.xml to nazwa a config katalog\
\
- mozna mieszac sposoby konfiguracji -> wszydstkie laduja w kontenerze\
\
<! - - w pokazany ponizej sposob importujemy inny plik do xml  - - >\
<import resource=\'84class path:config/castle-config.xml\'94/>\
\
//				KONFIGURACJA KOMPONENT\'d3W @Configuration\
\
 -> 3 spos\'f3b to konfiguracja za pomoc\uc0\u261  klasy konfiguracyjnej \
@Configuration // dzieki tej adnotacji Spring wie, \uc0\u380 e klasa ta zawiera definicje beanow\
@ImportResource(\'84classpath:config/castle-confi.xml\'94) // mozemy tez importowac pliki \
// konfiguracyjne XML do klasy\
public class MainConfig\{\
	\
	// ta klasa musi znajdowac sie na sciezce komponentow store sa przeszukiwane pod k\uc0\u261 tem beanow\
\
	@Bean\
	public Quest createQuest()\{\
		// to co dana metoda zwroci -> traktowane jako bean\
		return new Quest();\
	\}\
	\
	@Bean\
	public Knight createKnight()\{\
		Knight knight = new Knight();\
		\
		knight.setQuest( createQuest() ); // tu wstrzykujemy beana\
		return knight;\
	\}\
\
\}\
\
\
// mozemy wstrzyknac klase konfiguracyjna do innej przy pomocy adnotacji \
@Import(MainConfig.class)\
\
// 					Ktory sposob konfiguracji wybrac?\
\
-> kazdy projekt zaczynac od adnotacji @Component/@Autowired w roznych odmianach\
-> komponenty zewnetrzne -> wtedy klasy konfiguracyjne np. DataSource jest klasa zewnetrzna\
-> XML -> gdy mamy do czynienia ze starszymi aplikacjami (gdy XML byl glownym sposbem\
Tworzenia aplikacji)\
\
//				WZORZEC Singleton\
// klasy bezstanowe to klasy ktore zwieraja tylko metody statycznej (Utils) \
// czesto opatrzone sa annotacja @Singleton -> wtedy na JVM tylko jedna \
// instancja sie znajduje\
\
\
// ponizsza klasa ma problemy jezeli chodzi o Serializacje czy wielowatkowosc\
public class PersonUtils\{\
	\
	PersonUtils instance = null;\
	\
	// nie mozna stworzyc\
	private PersonUtils()\{\
\
	\}\
	\
	public PersonUtils getInstance()\{\
		if(instance == null)\{\
			instance = new PersonUtils();\
		\}\
\
		return instance;\
	\}\
\
\
	\
\
\
\}\
\
\
// prawidlowe tworzeniee: \
// sama Java zapewni ze bedzie to Singleton\
public enum PersonUtils2\{\
	INSTANCE:\
	\
	public final String operacja(Person person)\{\
		return person.name.toUpperCase();\
	\}\
\
\}\
\
\
// Stany to po prostu pola klasy\
\
\
//					Bean @Scope\
- domyslnie zasieg kazdego beana jest ustawiony na Singleton -> \
Bean ma dokladnie jedna instancje i wlasnie ona jest wstrzykiwana za kazdym razem jako \
Zaleznosc -> dlatego gdy jakas klasa w ktorej jest wstrzyknieta zmieni stan tego beana to \
Ta zmiana jest widziana w innych klasach do ktorych jest ona wstrzyknieta\
\
- oczywiscie mozna temu zaradzic bo istnieje drugi scope zwany prototype\
@Component\
@Scope(\'84singleto\'94) // nawet jakby tego nie bylo to wtedy ta klasa jest domyslnie singletonem\
\
// zeby to zmienic: \
@Component\
@Scope(\'84prototype\'94) // za kazdym razem gdy dany bean jest wstrzykiwany do innej klasy\
// to jest tam wstrzykiwana jej nowa instacja\
\
// zeby zmienic Scope w klasie konfiguracyjnej (oznaczonej annotacja @Configuration)\
// dodajemy pod @Bean annotacje @Scope(\'84prototype\'94)\
\
w xml jazzy bean ma atrubut scope = \'84prototype\'94/\'84singleton\'94\
\
- mamy 5 typow Scopow -> pozostale 3 dotycza juz aplikacji Webowych\
\
//					WSTRZYKIWANIE BEANOW TEGO SAMEGO TYPU\
\
// co zrobic gdy chcemy miec 2  roznych rycerzy(class Knight) jako komponenty a nie \
// kolejne instancje tego\
\
-> nie da sie tego zrobic z poziomu adnoatcji @Component czy @Scope\
\
-> mozemy w klasie konfiguracyjnej np skopiowac:  -> jednak spowoduje to \
-> blad -> mamy 2 beany tego samego typu !!! Bo gdy chcemy potem wstrzyknac rycerza\
-> z kontenera -> to blad \'85 \
\
@Configuration\
public class MainConfig\{\
	\
	@Autowired\
	Quest quest;\
	\
	@Bean(name=\'84lancelot\'94)\
	public Knight lancelot()\{\
		Knight lancelot = new Knight(\'84Lancelot\'94, 29);\
		lancelot.setQuest(quest);\
		return lancelot;\
	\}\
\
	@Bean(name=\'84persival\'94)\
	public Knight createKnightBean()\{\
		Knight persival = new Knight(\'84Persival\'94, 29);\
		persival.setQuest(quest);\
		return persival;\
	\}\
	\
\
\
\}\
\
// adnotacja @Qualifier(value=\'84lancelot\'94) -> przy parametrze konstruktora\
// w adnotacji tej podajemy nazwe konkretnego Beana, ktorego chcemy wstrzyknac\
// \
\
// do Castle jest wstrzykiwany rycerz\
@Autowired\
public Castle(@Qualifier(value=\'84lancelot\'94)Knight knight)\{\
	this.knight = knight;\
\
\}\
\
\
\
// annotacja Qualifier more bye rowniez przed polem, ktore jest wstrzykiwane np. \
// w ponizszej klasie wstrzykujemy  ( rozniej od Castle) wstrzykujemy konkretne pole: \
@Autowired\
@Qualifier(value = \'84percival\'94)\
Knight knight;\
\
// mozn tez beany skonsuowac przez XML -> ustawiajac odpowiednie\
// id w beanach\
\
// XML nie moze wstrzykiwac bezposrednio do pol\
\
// adnotacja @Primary\
// -> ustawiamy jednego z powtarzajacych sie Beanow tak i powodujemy wtedy ze \
// gdy nie podamy Qualifier to nie przekreci sie (crash) kontekstu (Springa/apki)\
\
// robimy to jak nizej \
\
@Configuration\
public class MainConfig\{\
	\
	@Autowired\
	Quest quest;\
	\
	@Bean(name=\'84lancelot\'94)\
	@Primary\
	public Knight lancelot()\{\
		Knight lancelot = new Knight(\'84Lancelot\'94, 29);\
		lancelot.setQuest(quest);\
		return lancelot;\
	\}\
\
	@Bean(name=\'84persival\'94)\
	public Knight createKnightBean()\{\
		Knight persival = new Knight(\'84Persival\'94, 29);\
		persival.setQuest(quest);\
		return persival;\
	\}\
	\
\}\
\
\
// efetk primary mosey rowniez uzyskac xml-em \
// dodajemy do bean atrybut primary=\'84true\'94\
\
\
//							WSTRZYKIWANIE KOLEKCJI\
\
public class Tournament\{\
	@Autowired\
	@Qualifier(value = \'84percival\'94)\
	List<Knight> knights; // oczywiscie Knight to bean\
\
\
	// metoda mutujaca\
	public void setKnight(List<Knight> knights)\{\
		this.knights = knights;	\
	\}\
\
\
// tutaj wstrzyknelo sie bez problemu. ..\
\
\}\
\
// dla Set -> tez bedzie dzialac\
public class Tournament\{\
	@Autowired\
	@Qualifier(value = \'84percival\'94)\
	Set<Knight> knights; // oczywiscie Knight to bean\
\
\
	// metoda mutujaca\
	public void setKnight(Set<Knight> knights)\{\
		this.knights = knights;	\
	\}\
\
\
// tutaj wstrzyknelo sie bez problemu. .. -> \
// jednak jak mamy Set to jak obiekty beda mialy taki sam Hash i equals to nie zostana wstrzykniete duplikaty\
\}\
\
// jezeli chcemy pewien podzbior wszystkich beanow Knight: -> najlepiej XML\
// Mapy nie jesesmy w stanie wstrzyknac - > XML \
// np. Jezeli chcemy wstrzyknac do klasy Tournament: \
<bean id=\'84tournament\'94  class=\'84com.clockworkjava.kursspring.domain.Tournament\'94>\
	<property name=\'84knights\'94>\
		<list>\
			<!\'97 tu podajemy nazwy beanow ktore chcemy wstezykiwac \'97>\
			<!\'97 sztuczne klasy -> zla metoda!!!\'97>\
			<ref bean=\'84percival\'94/>\
			<ref bean=\'84lancelot\'94/>\
			<!\'97 jesli Set to znacznik <set> \'85</set> \'97>\
			<!\'97 jesli 2 beany sa sobie rowne -> to wstrzykniety zostanie tylko jeden \'97>\
		</list>\
	</property>\
</bean>\
\
// w przypadku \
\
//@Autowired\
//Map<String, Knight> knights;\
To normlnie w XML :\
\
<bean id=\'84tournament\'94  class=\'84com.clockworkjava.kursspring.domain.Tournament\'94>\
	<property name=\'84knights\'94>\
		<map>	\
			<entry key=\'84Lancelot\'94 value-ref=\'84Lancelot\'94/>\
			<!\'97 .. . . .\'97>\
		</map>\
	</property>\
</bean>\
\
\
\
// 						CO POWINNO BYC BEANEM?\
\
-> wiele instancji np. Wielu rycerzy (dane przekazywane przez uzytkownika) -> rycerz to \
	nie powinien byc komponent\
-> zapisywanie/usuwanie obiektu domenowego -> nazywamy repozytoriami \
-> Spring oferuje annotacje @Repository -> robi to samo co komponent ale \
	jest ona uzywana dla programistow by wiedzieli ze jest to klasa odpowiedzialna\
	za zapisywanie/odczytywanie do pamieci/ bazy danych\
\
-> annotacja @Service -> klasy bezstanowe, komponenty springowe,\
	zestaw publicznych metod oblusgujacych czesc operacji biznesowych, \
	znowu przeznaczona bardziej dla programisty\
\
\
//					TASK SCHEDULER\
\
@EnableScheduling  dodana na poczatku klasy bedacej SpringBootem powopduje \
Zainicjalizowanie task schedulera (cos jak timer) \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
@Scheduled(fixedDelay = 1000) // powoduje ze ta metoda b\uc0\u281 dzie wykonywana co sekunde\
// fixedDealy dopiero po zakonczeniu calej metody czeka sekunde\
public void createRandomQuest()\{\
// \'85 \
\}\
-> uwaga!!! Aplikacja nie zamyka sie recznie bo caly czas dziala scheduler\
@Scheduled(fixedRate=1000) //teraz sekunda jest liczona od momentu wywolania metody \
\
@Scheduled(fixedRate = 1000, initialDelay = 3000)\
// initialDelay okresla po jakim czasie dana metoda ma zaczac sie wykonywac\
\
Taka annotacje mozemy rowniez parametryzowac stringiem przykladowo:\
Jezeli mamy jakis string okreslajacy wartosc w xml to wtedy: \
@Scheduled(fixedDelayString =\'84$\{stringZXML\}\'94)\
\
\'85 konfiguracja schedulera w XML: \
<task:scheduler id=\'84myScheduler\'94 pool-size=\'8410\'94/>\
\
// pool-size mowi (prawie) ile metod moze jednoczesnie byc obslugiwanych (?)\
\
// utworzenie zadania (w XML):\
<task:scheduled-tasks>\
	<task:scheduled ref=\'84questRepository\'94 method=\'84createRandomQuest\'94 fixed-rate=\'841000\'94/>\
</task:scheduled-tasks>\
// ref to klasa w ktorej znajduje sie metoda do wywolania co jakis czas\
// method -> nazwa metody\
// fixed-rate -> czas co jaki ma byc ona uruchamiana\
\
\
//					WZORZEC STRATEGII\
\
We wzorcu strategii chodzi o to by rozdzielic to co robi od tego w jaki sposob to robimy\
// chodzi o to by wsztrzyknac dynamicznie to jak cos zrobic -> np. jak sortowac liczby\
\
// Profil springowy okresla zestaw Beanow, ktory zostanie wlasnie w danym profilu np. \
// przy starcie aplikacji\
@Profile(\'84dev\'94) -> dodajemy przed definicja odpowiednich beanow\
@Profile(\'84prod\'94)\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf4 \cb3 @Bean\cf2 (\cf16 name \cf2 = \cf9 "DbKnightRepository"\cf2 )\
\cf4 @Profile\cf2 (\cf9 "prod"\cf2 )\
\cf6 public \cf2 KnightRepository \cf7 createDbKnightRepository\cf2 ()\{\
    \cf6 return new \cf2 DbKnightRepository()\cf6 ;\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf2 \}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf6 \cb3 spring.profiles.active \cf5 = \cf9 prod\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
\
To samo mo\uc0\u380 emy zrobi\u263  w XML -> \
Znacznik beans posiada atrybut profile np. <beans profile=\'84dev\'94 \'85\
\
//						SPRING MVC\
\
Tak jak zawsze -> wzorzec architektoniczny \
\
Controller -> praise widok I model \
View -> klikniety guzik -> przekazuje do Cotnroller (controller analizuje i przesyla do Modelu)\
	Model zwraca dane -> zwraca kontrolerowi -> kontroler tworzy strone\
\
// w Springu: \
1. Kazdy request trafia do FrontContorollera (tez wzorzec projektowy) -> w Springu nazywany\
	Dispatcher Servlet -> jego zadaniem jest przeslanie do odpowiedniego kontrolera\
2. Handler Mapping -> przesylany Request I handler na podstawie danych z requesta \
		jest w stanie wskazac konkretny controller -> zwraca taka informacje do Dispatcher 		Servlet\
3. Controller \'84rozbiera\'94 request -> parametry, metadane \'85 \
		// uwaga !! Spring ma kilka Controllerow\
4. Controller przesyla zadania do odpowiednich komponentow odpowiedzialnych za \
	logik\uc0\u281  biznesowa\
5. Po przetworzeniu idzie do Controllera z ktorego idzie widok do utworzenia do \
	Dispatcher Servleta -> idzie do View Resolvera(jest on w stanie wskazac \
		konkretna sciezke gdzie dany widok jest) -> potem zwroca odpowiedni \
		View ktory jest tworzony.\
\
//					HELLO SPRING MVC\
\
Dodawanie webowej strony springa: \
<dependency>\
	<groupId>org.springframework.boot</groupId>\
	<artifactId>spring-boot-starter-web</artifactId>\
</dependency>\
\
Adnotacja @Controller powoduje ze dana klasa staje sie kontrolerem\
Localhost:8080 -> domyslny link TomCata\
\
Po tym nalezy zamapowac odpowiedni request dla przegladarki \
@RequestMapping(\'84/hello\'94) // obsluguje request hello\
public String hello()\{\
	return \'84hellospring.html\'94; // to jest HTML \
\}\
\
// domyslnie statyczne strony html umieszczamy w resources w podkatalogu srtatic \
I naywamy odpowiednia nazwa \'85 np. tutaj  helloworld.html\
\
\
//				THYMELEAF I PRACA Z MODELEM\
\
\
Controller jest komponentem Front-Endowym kontroluj\uc0\u261 cym widok i model \
Repozytorium jest komponentem ktory ma za zadanie komunikowac sie z baz danych \
-> lepiej nie mieszac tych dwoch elementow \
-> warto mieszy nimi umiescic Service\
\
Dane z kilku widokow -> DTO (Data Transfer Object)\
\
//\'85.\
Przyklad przekazywania modelu do odpowiedniej metody: \
@RequestMapping(\'84/knight\'94)\
public String getKnight(Model model)\{\
	//knightService to wstrzykniety  odpowiedni Service \
	List<Knight> allKnights = knightService.getAllKnights();\
	model.addAttribute(\'84knights\'94, allKnights);\
	return \'84knights\'94; // juz bez rozszerzenia .html bo to templatka dynamiczna\
\}\
\
\
//  zeby widok mogl cos zrobic z modelem mozemy uzyc jakis silnik \'84templatek\'94 \
// np. JSP czy Thymleaf (powiazany ze Springiem)\
\
// -> dodawanie go do xml: \
<dependency>\
		<groupId>org.springframework.boot</groupId>\
		<artifactId>spring-boot-starter-thymelead</artifactId>\
</dependency>\
\
Domyslnie strony thymeleafa laduja w resources -> templates \
\
@RequestMapping(\'84/knight\'94)\
public String getKnight(Model model)\{\
	//knightService to wstrzykniety  odpowiedni Service \
	List<Knight> allKnights = knightService.getAllKnights();\
	model.addAttribute(\'84knights\'94, allKnights);\
	model.addAttribute(\'84hello\'94,\'94Witaj \uc0\u347 wiecie\'94); // potem z takiego atrybutu mozemy\
	// odpowiednio skorzystac w html i wyswietlic na stronie\
	return \'84knights\'94; // juz bez rozszerzenia .html bo to templatka dynamiczna\
\}\
\
<p th:text=\'84$\{hello\}\'94/>\
\
\
// obiekty (lista) ; \
<div th:each=\'84knight : $\{knights\}\'94>\
	<p th:text=\'84$\{knight\}\'94/>\
</div>\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf17 \cb3 <table>\
    <thead>\
        <tr>\
            <td>\cf2 Imie rycerza\cf17 </td>\
            <td>\cf2 Wiek\cf17 </td>\
        </tr>\
    </thead>\
    <tbody \cf8 th\cf18 :each=\cf19 "knight : $\{knights\}"\cf17 >\
        <tr>\
            <td \cf8 th\cf18 :text=\cf19 "$\{knight.name\}"\cf17 />\
            <td \cf8 th\cf18 :text=\cf19 "$\{knight.age\}"\cf17 />\
        </tr>\
    </tbody>\
</table>\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \cb1 \
//					WEBJARS\
\
-> Webjars -> Biblioteki webowe, ktore sa opakowane w archiwum jar\'92a -> moja \
	byc dodane do konfiguracji mavena \
-> np celem zaciagniecia webjarsow reprezentujacych jquerry czy bootstrap: \
		<dependency> \
			<groupId>org.webjars</groupId>\
			<artifactId>jquerry</artifactId>\
			<version>3.2.1</version>\
		</dependency>\
\
// przyklad jak podciagnac bootstrapa do html - > \
W <head>\
\
<title rel=\'84stylesheet\'94  th:href=\'84@\{/webjars/bootstrap/3.3.7-1/css/bootstrap.min.css\}\'94/>\
// analogicznie skrpyty js -> znacznik <script> \'85\
\
//					UTWORZENIE NOWEGO RYCERZA\
\
// przykladowy formularz tupescirptu: \
<form class=\'84form-horizontal\'94 th:object=\'84$\{knight\}\'94  \
					th:action=\'84@/products\'94 th:method=\'84post\'94/>\
\
th:object to obiekt ktory zostanie przeslany\
th:action to adres url gdzie zostanie przekazany ten obiekt\
th:method  -> to metoda protokul http ktora zostanie uzyta\
\
// w srodku tagu <form> towrzymy odpowiednie inputy na dane\
<div class=\'84form-group\'94>\
	<label class=\'84control-label\'94>Imie:</label>\
	<input type=\'84text\'94 class=\'84form-control\'94 th:field=\'84*\{name\}\'94/>\
</div>\
Parametr th:field okresla nazwe pola obiektu okreslonego w form \
	ktore zostanie zainicjalizowane wartoscia z tego input\'92a\
\
// metoda do obslugiwania formularza: \
@RequestMapping(value = \'84/knights\'94, method = RequestMethod.POST)\
public String saveKnight(Knight knight)\{\
	knightServices.saveKnight(knight); // przy pomocy service zapisujemy \
	return \'84redirect:/knights\'94;  // tutaj przekierowujemy do strony ze wszystkimi rycerzami\
\}\
\
\
// 			WIDOK SZCZEG\'d3\uc0\u321 OWY RYCERZA \
\
// przekierowanie do podstrony, ze szczegolwami rycerza: \
<a th:href=\'84$\{\'82/knight?id=\'82+knight.id\}\'94>Podgl\uc0\u261 d</a> \
// w tym html uzywamy parametr url do przekazania id rycerza, ktory zostal klikniety\
\
// pobieranie argumentow z url w controllerze: \
\
@RequestMapping(\'84/knight\'94)\
public String getKnight(@RequestParam(\'84id\'94) Integer id, Model model)\{\
	\
\}\
\
// 		    USUWANIE RYCERZA\
\
Id mozemy przesylac przez URL albo przez sciezke \
 Ponizszy przyklad reprezentuje przyklad przesylania przez sciezke: \
\
<a th:ref=\'84$\{\'82/knight/delete/\'82+knight.id\}\'94>Usun</a>\
\
\
Bardziej popularne jest jednak przesylanie przez sciezke \
\
W kontrolerze taki argument w sciezce obsluguje sie jak nizej: \
@RequestMapping(value = \'84/knights/delete/\{id\}\'94)\
public String deleteKnight(@PathVariable(\'84id\'94) Integer id)\}\
	//\'85 jakis kod\
\
\}\
\
\
\
//			WEB SCOPES\
\
	// Prototype\
	// SIngleton \
// w webowym: \
	// Request\
	//Session\
// czas powinno sie robic w JavaScript a nie przez backend ale tutaj tak bedzie\
<p th:text=\'84$\{timecomponent.time\}\'94/>\
\
prototype  w webowe -> kazda sesja ta sama godzina !!!\
	lepiej u\uc0\u380 y\u263  @Scope(value = \'84request\'94, proxyMode = ScopedProxyMode.TARGET_CLASS)\
			// dzieki temu mozna wstrzyknac komponent o kontekscie webowym -> godzina 				sie  zmienia  -> dzieki temu ze jestr request to co request jest wstrzykiwanie \
// (cofanie nie daje nowego requesta!!!);\
// klasa wstrzykiwana jako godzina: \
@Component\
@Scope(\'84prototype\'94)\
public class TimeComponent\{\
\
	private TImeComponent time = LocalDateTime.now();\
\
// gettery i settery dla HTML \
\
\}\
\
\
\
// jeszcze moze byc session scope, czyli \
@Scope(value = \'84session\'94,  proxyMode = ScopedProxyMode.TARGET_CLASS) \
-> teraz godizna odswieza sie kiedy mamy nowa sesje (np. Przegladarka w \
		w trybie prywatnym a potem w zwyklym)\
\
//					WALIDACJA FORMULARZY\
\
// Spring wspiera API Javy EE tzw. Bean validation \
\
np. Adnotacja @NotNull przy polach co nie maja byc nullem \
@Min(2) // przy polu typu int naklada ograniczenie na minimalna wielkosc \
@Max(40)  // przy polu typu int naklada ograniczenie na maksymalna wielkosc \
// przy stringach ograniczenie na dlugosc nakladamy jako: \
@Size(min = 2, max = 40) // ofraniczenie na stringa\
// mozna rowniez podawac im customowe wiadomosci: \
@Size(min = 2, max = 40, message = \'84Moja wiadomosc o bledzie\'94)\
\
@Range( min = 18, max = 80) // nak\uc0\u322 adamy ograniczenia na pole typu int\
\
Po takim oznaczeniu odpowiednich pol w klasie modelujacej dany obiekty aplikacji (Np. Uzytkownika, postac z gry itd.) \
Nalezy w kontrolerze zrobic cos takiego: \
@RequestMapping(value = \'84/knights\'94, method = RequestMethod.POST)\
public String saveKnight(@Valid Knight knight, BindingResult bindingResult)\{\
	\
	if(bindingesult.hasErrors())\{\
		System.out.println(\'84There were errors\'94);\
		return \'84/knightform\'94;\
	\}else\{\
		service,saveKnight(knight);\
		return \'84redirect:/knights\'94;\
\
	\}\
\
\
\}\
\
// adnotacja @Valid powoduje sprawdzanie poprawnosci danych \
// BindingResult to obiekt, ktory pomaga okreslic czy mial miejsce blad czy nie\
\
// mozna za pomoca bindingResult uzyskac bardziej konkretne wiadomosci o bledach: \
\
bindingResult.getAllErrors().forEach(\
		error->\{\
			System.out.println(\'84error.getObjectName() + \'84 \'84 + error.getDefaultMessage());\
	\});\
\
// wypisywanie bledow w forumalrzu w przegldarce: \
<p th:if=\'84$\{#fields.hasErrors(\'82name\'92)\} th:errors=\'84*\{age\}\'94/>\
// powyzsza konstrukcja jestli wystapily beldy przwpisywaniu age \
// wypisuje je \'85 fields to wbudowany obiekt w th -> nie trzeba go definiowac oddzielnie\
\
// 				METODY BIZNESOWE\
\
// interesujaca konstrukcja -> oczywiscie odpowiednie gettery i settery musza byc w odpowiednich klasach\
\
<span th:if=\'84$\{knight.quest == null\}\'94 th:text=\'84\'82Brak aktualnego zadania\'92\'94/>\
\
// z hamcrest -> obecnie jest juz dolaczona do JUNIT\'92a assertThat : \
assertThat(allNotStartedQuests, containsInAnyOrder(q1,q3));\
// allNotStartedQuests to lista questow \
\
Jak mamy mocki w testach to musimy w klasie ktora jest testem dodac odpowiedniego \
Runnera: \
@RunWith(MockitoJUnitRunner.class)\
\
//					PRZYPISYWANIE ZADAN\
\
Java 7/8 -> defaultowa implementacja w interfejsie: \
public interface MyInterface\{\
	default void myMtehod()\{\
		throw new NotImplementedException();\
\
	\}\
\
\}\
\
\
Czasami moze byc potrzeba utworzenia ukrytych pol celem przechowania i odzyskania tego samego stanu obiektu: \
<input type=\'84hidden\'94 th:field=\'84*\{id\}\'94/>\
\
//				TESTOWANIESPRING MVC\
\
@WebAppConfiguration -> adnotacja do oznaczania klasy gdzie znajduj\uc0\u261  si\u281  testy \
	zwi\uc0\u261 zane ze Spring MVC\
\
@Mock -> tak oznaczamy pola klas ktorre beda Mockowe z pomoca Mockito\
\
@InjectMock -> tak oznaczamy klase do ktorej chcemy wstrzyknac dane mocki\
\
\
// mozna stworzyc metode stora zostanie wykonana przed kazdym testem: \
\
@Before\
public void setUp()\{\
	MockitoAnnotations.initMocks(this); // aktywuje wszystkie mocki i wsztrzykuje je do odpowiedniego \
\}\
\
MockMvc -> klasa Springowa sluzaca do testowania MVC springowego\
// budowanie takiego obiektu odbywa sie jak ponizej: \
MockMvc mockMvc = MockMvcBuilders.standaloneSetup(questController).build();\
\
// zeby \'84uderzyc\'94(wyslac odpowiednia metode) w odpowiedni link do mock\'92a\
// nalezy uzyc jak nizej: \
mockMvc.perform(get(\'84/nazwaLinku\'94));\
\
// przy perform mozemy ustawiac odpowiednie atrybuty np. \
mockMvc.perform(get(\'84/nazwaLinku\'94).requestAttr(\'84id\'94,1));\
\
Na takim mocku mozmey rowniez sprawdzac inne rzeczy: \
mockMvc.perform(get(\'84/nazwaLinku\'94)).\
		andExpect(status().is3xxRedirection()) // sprawdza kod odpowiedzi\
		.andExpect(view().name(\'84redirect:/knights\'94));		// sprawdza widok, ktory zostanie zwrocony\
\
//			JAVA PERSISTENCE API \
\
JPA -> interfejs do mapowania obiektow czystow Javovwych na relacyjne bazy danych \
H2 -> baza danych w pamieci -> proste przyklady/ proste aplikacje\
// dzialanie JPA\
EntinityManagerFactory -> singleton gdzie trzymana jest pula polaczen do bazy danych/ tez\
		tworzy EntityManager (w hibernate -> SessionFactory)\
\
EntityManager -> obiekt sesji, ktory tworzymy za kazdym razem nowy gdy chcemy wykonac\
	jakas operacje na bazie danych (Hibernate -> Session)\
\
@PersistenceContext\
\
//				DODANIE JPA DO PROJEKTU\
\
W pliku pom.xml 2 zaleznosci: \
	<dependency>\
		<groupId>org.springframework.boot</groupId>\
		<artifactId>spring-boot-starter-data-jpa</artifactId>\
	</dependency>\
\
// 2 zaleznosc to:\
	<dependency>\
		<groupId>com.h2database</groupId>\
		<artifactId>h2</artifactId>\
	</dependency>\
		\
H2 -> spring ja automatycznie konfiguruje -> nowa przy kazdym starcei aplikacji \
\
W properties wpis wlaczajacy konsole: \
spring.h2.console.enabled=true\
\
I mozemy po tym wpisie odpalic konsople linkiem\
/h2-console\
\
// 		TWORZENIE PIERWSZYCH PERSYSTENCJI \
\
-> nalezy dodac adnotacje @Entity\
-> oraz pole reprezentujace id oznaczone przez @Id\
	@Id\
	@GeneratedValue(strategy = GenerationType.AUTO) // strategia generacji jako AUTO -> unikalne -> z reguly inkrementowane jako jeden\
-> pusty konstruktor\
\
-> laczac sie poprzez konsole nalezy nastepnie wybrac (domyslne jest) przy jdbc url\
		jdbc:h2:mem:testdb \
\
Mozna nadac swoja nazw bazy danych poprzez plik application.properties: \
\
spring.datasource.url=jdbc:h2:mem:mydb\
\
// zeby widziec jakie zapytania zostaly wykonane przez Hibernate w konsoli\
// wystarczy wpisac: \
spring.jpa.properties.hibernate.show_sql=true\
spring.jpa.properties.hibernate.format_sql=true\
\
Gdy nie chcemy zeby jakies pole bylo zapisywane do bazy danych \
	wystarczy uzyc na tym polu adnotacji @Transient\
\
Jesli podamy na polu o nazwie id adnotacje @Id wowczas do\
	zapisywania do bazy danych i odczytywania jest uzywana refleksja\
\
A jesli takie adnotacji uzyjemy powyzej getId wowczas\
	Hibernate bedzie uzywal do obslugi mapowamia do i z bazy danych getterow\
		i setterow\
Jesli chcemy zmioenic nazwe tablicy to \
@Table(name = \'84Zadania\'94) -> przed nazwa klasy\
\
A jesli kolumny to przed nazwa pola ktore reprezentuje\
@Column(name = \'84 Nazwa kolumny\'94)\
\
\
Oczywiscie klasa moze byc i encja i komponentem Springa \
	ale trzeba uwazac na czytelnosc by nie przesadzic ;) \
\
\
//				RELACJE\
\
Jezeli obiekt jakiejsc klasy jest \'84wbudowany\'94 (tzn. Zawiera pole typu ktory nie jest \
	prymitywem) w inny obiekt klasy to mozemy go okreslic np. Adnotacja\
		\
	@Embedded -> typ danych ktory jest scisle zwiazy e encja w ktorej sie znajduje\
		ale dla wygody i przejrzystosci przeniesiony do innej klasy ale nalezy do \
			tej samej tabeli c oklasa w ktorej sie znajduje\
\
	lub mozna go oznaczyc jako relacje \
\
	RELACJE ZACHODZA MIEDZY ENCJAMI ZAWIERAJACYMI ID\
\
	1-1 (@OneToOne)\
	1- wiele (@OneToMany)\
	wiele- wiele(@ManyToMany)\
\
//				ZAPISYWANIE DANYCH\
\
By wykonac operacje na bazie danyuch potrzebujemy wsztrzyknietego przez\
	EntinityManagerFactory obiektu EntityManager\
	\
	@PersistenceContext\
	private EntityManager entinityManager;\
\
	// zapisyeanie do bazy\
	entityManager.persist(jakisObiekt);\
	\'97 metode w ktorej jest wywolywana \
		metoda persist trzeba oznaczyc jako \
			@Transactional\
				-> to jest od teraz transakcja ->\
					jesli bedzie np., wyjatek w srodku to nie spowoduje to \
						zapisu do bazy danych (wszystko co zostanie \
								wykonane przez tym wyjatkiem zostanie \
									cofniete)\
\
// wystosowanie zapytania do takiej \'84bazy\'94 \
entinityManager.createQuery(\'84from Nazwa_Tabeli\'94, Quest.class);\
	na tak uzyskanym obiekcie mozemy wtedy wywolac metode\
			getResultList() po to by uzyskac liste tych obiektow\
\
// usuwanie z takiej bazy danych: \
entinityManager.remove(obiekt_Reprezentujacy_To_co_chcemy_usunac);\
\
// updatowanie odpowiedniego wpisu w bazie danych: \
entinityManager.merge(ObiektKtoryChcemyMergowac);\
\
// pobieranie o zadanym id: \
entinityManager.find(Quest.class, id);\
\
// zapytanie do bazy z wherem : \
	entinityManager.createQuery(\'84from Knight k where k.name = :name\'94, Knight.class).\
				setParameter(\'84name\'94, name).\
				getSingleResult();\
	return Optional.ofNullable(knight);\
//			DODANIE SPRING SECURITY DO PROJEKTU\
\
<dependecny>\
	<groupId>org.springframework.boot</groupId>\
	<artifactId>spring-boot-starter-security</artifactId>\
</dependency>\
\
// wowczzas w klasie konfigurujacej mozemy wstrzyknac metode tworzaca\
// odpowiednich userow: \
// inMemoryUsers to bardziej do testow i do dev a nie do produkcji !!!\
@Autowired\
public void securityUsers(AuthenticationManagerBuilder auth) throws Exception\{\
	auth.inMemoryAuthentication().withUser(\'84user1\'94).password(\'84user2\'94).roles(\'84USER\'94).\
		and().\
	withUser(\'84user2\'94).password(\'84user2\'94).roles(\'84ADMIN\'94);\
\
\}\
\
//			PROSTY FORMULARZ LOGOWANIA\
\
\
// przycisk do wylogowywania: \
# ->  bo zostaje na tej samej stronie \
<form action=\'84#\'94  th:action=\'84@\{/logout\}\'94 method=\'84post\'94>\
	<input type=\'84submiT\'94 value=\'84Logout\'94/>\
</form>\
-> pod /logout -> Spring domyslnie tworzy  wylogowywanie sesji usera\
\
// mozemy stworzyc odpowiednia klase odpoweidzialna za konfigurowanie logowania (bezpieczenstwa)\
	naszej aplikacji\
@Configuration\
public class SecurityConfig extends WebSecurityConfigurerAdapter\{\
	@Autowired\
	public void securityUsers(AuthenticationManagerBuilder auth) throws Exception\{\
		auth.inMemoryAuthentication().withUser(\'84user1\'94).password(\'84user2\'94).roles(\'84USER\'94).\
			and().\
		withUser(\'84user2\'94).password(\'84user2\'94).roles(\'84ADMIN\'94);\
\
	\}	\
\
\
\
	@Override\
	public void configure(HttpSecurity security) throws Exception\{\
		// dzieki obiektowi HttpSecurity mosey ustalic regally ktore beda dotyczyly\
		// naszej strony; bedzie mozna ustalic. Jakie url\'92y maja jaki poziom dostepu\
		// i kto bedzie (z jakimi rolami) bedzie mogl na nie wchodzic\
		// dwie gwiazdki oznaczaja ze wszystko co jest za tym adresem rowniez\'85\
		security.authorizeRequests().antMatchers(\'84/h2-console/**\'94).permitAll().\
			antMatchers(\'84/knights\'94).hasAnyRole(\'84USER\'94,\'94ADMIN\'94).\
				antMatchers(\'84/knight\'94).hasAnyRole(\'84ADMIN\'94).\
					anyRequest().authenticated().and().formLogin().\
						defaultSuccessUrl(\'84/knights\'94);\
			//defaultSuccessUrl() przekierowuje pod zadany link po stwierdzeniu udanego logowania\
			// metoda httpBasic() wywoluje podstawowy \'84formularz\'94 logowania\
				// -> wyskakujace okienko proszace o logowanie ;) \
			//formLogin() -> predefiniowany formularz do logowania ktory ma sie wyswietlic\
	\}\
\
\
\}\
\
\
//					AUTENTYKACJA Z UZYCIEM BAZY DANYCH\
\
\
// oczywiscie haslo nalezy zakodowac jako hasha a nie trzymac jawnie jak w kursie ;) \
\
1. Potrzebujmy obiektu ktory bedzie trzymal informacje o userze.\
2. Potrzebujemy obiketu ktory bedzie trzymal informacje o rolach\
3. Repozytorium\
\
\

\b // uwga jak przechodzimy w Springu na baze danych to zmiast uzywac hasAnyRole\
// nalezy uzywac hasAnyAuthority !!! Do konfiguracji dostepu po rolach\
\

\b0 pobranie odpowiednich uzytkownikow oraz ich rol z bazy danych\
\
@Autowired\
public void security(AuthenticationManagerBuilder auth) throws Exception\{\
	// datasouce mozemy wstrzyknac\
	auth.jdbcAuthentication().dataSoutce(dataSource).\
		usersByUsernameQuery(\'84SELECT username, password, enabled FROM PLAYER_INFORMATION WHERE username = ? \'84) .\
			authoritiesByUsernameQuery(\'84SELECT username, role FROM ROLE WHERE username = ?\'94);\
\
// w metodzie userByUsernameQuery() podajemy zpaytanie wyybierajace na podstawie ktorego\
// maja zostac pobrani uzytkownicy naszej aplikacji \
\
// w authoritiesByUsernameQuery() podajemy role (zapytanie wybierajace role)\
\
\}\
\
\
//			DEPLOYMENT NA SERWER ZEWNETRZNY\
\
mozna wykupic swoja wlasna maszyne wirtualna i tam postawic swoja aplikacje\
\
-> Digital Ocean cala wirtualna maszyna\
-> MyDevil.net -> troche tanszy ale nie ma wszystkich opcji \
\
Logowanie na server za pomoca ssh:\
\
ssh root@odpowiednie_ip_servera\
\
Zeby aplikacja sie nie zamknela po zamknieciu konsoli mozna uruchomic ja w tle \
	-> uzywajac na koncu java -jar aplikacja.jar & \
\
Lub\
\
1. Komenda screen \
2. java -jar jakasNazwa.jar \
3. Zamknac screena -> ctrl+a a nastepnie t -> poprzedni widok lub controt + a + d \
Powrot do niego screen -dr \
\
//			Rozszerzenie: \
\
Customowy formularz rejestracji z opcja rejestracji i akceptacji uzytkownikow\
Postres na wirtualnej i laczyc sie z nim \
Losowe czasy i nagrody za zadania\
Ekwipunek\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
 }